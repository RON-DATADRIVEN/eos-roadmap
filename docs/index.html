<!doctype html>
<html lang="es" data-issue-service-url="https://create-issue-rondatadriven.uc.r.appspot.com">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EOS ‚Äì Roadmap p√∫blico</title>
  <meta name="description" content="Evoluci√≥n de m√≥dulos de la plataforma EOS " />
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div class="header">
    <div class="container">
      <div class="header-main">
        <div>
          <h1>EOS ‚Äì Roadmap p√∫blico</h1>
          <p>
            Seguimiento de m√≥dulos y estado.
            <a class="link" href="https://github.com/orgs/RON-DATADRIVEN/projects/3/views/1?layout=board" target="_blank" rel="noopener">Ver plan en completo en GitHub Projects</a>
          </p>
        </div>
        <button id="openIssueModal" class="btn" type="button" aria-haspopup="dialog" aria-controls="issueModal">Crear issue</button>
      </div>
    </div>
  </div>

  <main class="container">
    <section class="controls">
      <select id="statusFilter" aria-label="Filtrar por estado">
        <option value="">Todos los estados</option>
        <option value="Planificado">Planificado</option>
        <option value="En curso">En curso</option>
        <option value="Hecho">Hecho</option>
      </select>
      <input id="search" type="search" placeholder="Buscar m√≥dulo..." />
    </section>

    <section id="grid" class="grid" aria-live="polite"></section>

    <div class="footer" id="footer"></div>
  </main>

  <div id="issueModalOverlay" class="modal-overlay hidden" role="presentation">
    <div
      id="issueModal"
      class="modal"
      role="dialog"
      aria-modal="true"
      aria-labelledby="issueModalTitle"
      aria-describedby="issueModalDescription"
      tabindex="-1"
      data-issue-beacon-url="https://script.google.com/macros/s/AKfycbxc4mOzsOjx-r0ROx2VNlrP_9g2-02tG7Q1Uc_JVyUgtbr3nzi4f39Kyw5VQ_OcZkADFg/exec"
    >
      <button id="closeIssueModal" type="button" class="modal-close" aria-label="Cerrar">
        √ó
      </button>
      <h2 id="issueModalTitle">Crear issue</h2>
      <p id="issueModalDescription" class="modal-description">Selecciona una plantilla para generar el contenido del issue.</p>
      <div class="modal-body">
        <aside class="template-selector" aria-label="Plantillas de issue">
          <h3>Plantillas</h3>
          <ul id="templateList" class="template-list" role="list"></ul>
        </aside>
        <section class="template-form" aria-live="polite">
          <div class="template-meta">
            <p id="templateSummary" class="template-summary"></p>
            <div id="issueLabels" class="issue-labels" aria-label="Etiquetas aplicadas"></div>
          </div>
          <form id="issueForm" novalidate>
            <div class="field">
              <label for="issueTitle">T√≠tulo</label>
              <input id="issueTitle" name="issueTitle" type="text" required />
            </div>
            <div id="issueFields" class="field-group"></div>
            <div class="form-actions">
              <button id="submitIssue" type="submit" class="btn primary">Crear issue</button>
            </div>
          </form>
          <div id="issueFormMessage" class="form-message" role="alert" aria-live="assertive"></div>
          <pre id="payloadPreview" class="payload-preview hidden" tabindex="0" aria-label="Vista previa del cuerpo del issue"></pre>
        </section>
      </div>
    </div>
  </div>

  <script>
    const grid = document.getElementById('grid');
    const statusFilter = document.getElementById('statusFilter');
    const search = document.getElementById('search');
    const footer = document.getElementById('footer');
    const openIssueModalBtn = document.getElementById('openIssueModal');
    const modalOverlay = document.getElementById('issueModalOverlay');
    const issueModal = document.getElementById('issueModal');
    const closeIssueModalBtn = document.getElementById('closeIssueModal');
    const templateList = document.getElementById('templateList');
    const templateSummary = document.getElementById('templateSummary');
    const issueLabels = document.getElementById('issueLabels');
    const issueForm = document.getElementById('issueForm');
    const issueFields = document.getElementById('issueFields');
    const issueTitle = document.getElementById('issueTitle');
    const issueFormMessage = document.getElementById('issueFormMessage');
    const payloadPreview = document.getElementById('payloadPreview');

    function getBeaconUrl() {
      // Poka-yoke: Primero revisamos el atributo data-issue-beacon-url del modal para reutilizar la configuraci√≥n declarativa del HTML.
      const domValue = (issueModal && issueModal.dataset.issueBeaconUrl ? issueModal.dataset.issueBeaconUrl : '').trim();
      if (domValue) {
        return domValue;
      }

      // Poka-yoke: Si el HTML no trae el valor, usamos la variable global window.ISSUE_BEACON_URL para mantener compatibilidad con configuraciones anteriores.
      const windowValue = (window.ISSUE_BEACON_URL || '').trim();
      if (windowValue) {
        return windowValue;
      }

      // Poka-yoke: Cuando no se encuentra ning√∫n valor lanzamos un error expl√≠cito para evitar que el formulario se env√≠e sin destino.
      throw new Error('Servicio de issues no configurado. Contacta al administrador.');
    }

    let modules = [];
    let currentTemplateId = null;
    let lastFocusedElement = null;

    const issueTemplates = [
      {
        id: 'blank',
        name: 'üóø Issue',
        description: 'Issue libre con estructura m√≠nima',
        title: '[ISSUE] T√≠tulo',
        labels: ['Status: Ideas', 'Tipo :Blank Issue'],
        body: [
          {
            type: 'textarea',
            id: 'descripcion',
            label: 'Descripci√≥n',
            placeholder: 'Escribe aqu√≠‚Ä¶',
            value: '**Contexto**\n-\n\n**Detalles**\n-\n\n**Criterio de aceptaci√≥n**\n-'
          }
        ]
      },
      {
        id: 'bug',
        name: 'üêû Bug',
        description: 'Reportar un defecto',
        title: 'fix: <resumen>',
        labels: ['Tipo: Bug', 'Status :En planeaci√≥n'],
        body: [
          {
            type: 'input',
            id: 'summary',
            label: 'Resumen',
            placeholder: 'Error 500 al crear programa',
            required: true
          },
          {
            type: 'textarea',
            id: 'steps',
            label: 'Pasos para reproducir',
            placeholder: '1. Ir a /programas ‚Üí 2. Click en crear ‚Üí 3. ...',
            required: true
          },
          {
            type: 'textarea',
            id: 'expected',
            label: 'Comportamiento esperado',
            required: true
          },
          {
            type: 'textarea',
            id: 'actual',
            label: 'Comportamiento actual',
            required: true
          },
          {
            type: 'textarea',
            id: 'env',
            label: 'Entorno',
            placeholder: 'Prod/Stg/Dev, navegador, versi√≥n'
          },
          {
            type: 'textarea',
            id: 'logs',
            label: 'Logs/evidencia'
          }
        ]
      },
      {
        id: 'change_request',
        name: 'üìù Solicitud de Cambio',
        description: 'Solicitar un cambio de alcance/alcance t√©cnico',
        title: 'chore: change-request <resumen>',
        labels: ['Tipo: Change Request', 'Status: Ideas'],
        body: [
          {
            type: 'markdown',
            id: 'intro',
            value: 'Describe el cambio propuesto y el impacto (tiempo, costo, riesgo). Ser√° evaluado.'
          },
          {
            type: 'textarea',
            id: 'description',
            label: 'Descripci√≥n del cambio',
            required: true
          },
          {
            type: 'textarea',
            id: 'impact',
            label: 'Impacto (alcance/tiempo/costo/riesgo)',
            required: true
          },
          {
            type: 'input',
            id: 'requester',
            label: 'Solicitante',
            placeholder: '@stakeholder',
            required: true
          }
        ]
      },
      {
        id: 'feature',
        name: '‚öô Feature',
        description: 'Nueva capacidad o mejora',
        title: '[FEAT] T√≠tulo de la feature',
        labels: ['Tipo: Feature', 'Status: Ideas'],
        body: [
          {
            type: 'textarea',
            id: 'descripcion',
            label: 'Descripci√≥n',
            placeholder: 'Como [rol] quiero [funci√≥n] para [beneficio]',
            required: true
          },
          {
            type: 'input',
            id: 'criterio',
            label: 'Criterio de aceptaci√≥n (resumen)',
            placeholder: 'Dado/Cuando/Entonces...',
            required: true
          }
        ]
      }
    ];

    function renderTemplateOptions() {
      templateList.innerHTML = '';
      issueTemplates.forEach(template => {
        const item = document.createElement('li');
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'template-option';
        button.dataset.templateId = template.id;

        const name = document.createElement('span');
        name.className = 'template-name';
        name.textContent = template.name;

        const description = document.createElement('span');
        description.className = 'template-option-description';
        description.textContent = template.description;

        button.append(name, description);
        button.addEventListener('click', () => selectTemplate(template.id));

        item.appendChild(button);
        templateList.appendChild(item);
      });
    }

    function selectTemplate(templateId) {
      const template = issueTemplates.find(t => t.id === templateId);
      if (!template) {
        return;
      }

      currentTemplateId = templateId;

      templateList.querySelectorAll('.template-option').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.templateId === templateId);
      });

      templateSummary.textContent = template.description;
      issueLabels.innerHTML = '';
      template.labels.forEach(label => {
        const badge = document.createElement('span');
        badge.className = 'label-chip';
        badge.textContent = label;
        issueLabels.appendChild(badge);
      });

      payloadPreview.classList.add('hidden');
      payloadPreview.textContent = '';
      clearMessage();

      populateTemplateFields(template);
    }

    function populateTemplateFields(template) {
      issueTitle.value = template.title;
      issueTitle.placeholder = template.title;

      issueFields.innerHTML = '';
      template.body.forEach(field => {
        if (field.type === 'markdown') {
          const wrapper = document.createElement('div');
          wrapper.className = 'field markdown';
          wrapper.dataset.type = 'markdown';
          wrapper.dataset.value = field.value || '';

          const label = document.createElement('p');
          label.className = 'markdown-hint';
          label.textContent = field.value || '';
          wrapper.appendChild(label);

          issueFields.appendChild(wrapper);
          return;
        }

        const wrapper = document.createElement('div');
        wrapper.className = 'field';
        wrapper.dataset.type = field.type;
        wrapper.dataset.fieldId = field.id;
        wrapper.dataset.label = field.label || field.id;

        const label = document.createElement('label');
        label.textContent = field.label || field.id;

        const controlId = `issue-field-${template.id}-${field.id}`;

        let control;
        if (field.type === 'textarea') {
          control = document.createElement('textarea');
          control.rows = 4;
        } else {
          control = document.createElement('input');
          control.type = 'text';
        }

        control.id = controlId;
        control.name = field.id;
        control.placeholder = field.placeholder || '';
        if (field.required) {
          control.required = true;
          wrapper.classList.add('required');
        }
        if (field.value) {
          control.value = field.value;
        }

        label.setAttribute('for', controlId);

        control.addEventListener('input', () => {
          wrapper.classList.remove('invalid');
        });
        control.addEventListener('blur', () => {
          if (control.required && !control.value.trim()) {
            wrapper.classList.add('invalid');
          }
        });

        wrapper.append(label, control);
        issueFields.appendChild(wrapper);
      });
    }

    function toIssuePayload(formData) {
      // Identificamos la plantilla vigente para evitar enviar datos sin estructura.
      const template = issueTemplates.find(t => t.id === currentTemplateId);
      if (!template) {
        // Si no encontramos la plantilla devolvemos null para que la llamada se detenga.
        return null;
      }

      // Creamos un diccionario con los valores capturados para prevenir omisiones.
      const fieldValues = {};
      // Acumulamos secciones en Markdown para que el equipo reciba un resumen legible.
      const sections = [];
      // Usamos un Set para eliminar etiquetas duplicadas sin dejar la responsabilidad al backend.
      const labels = new Set(Array.isArray(template.labels) ? template.labels : []);

      template.body.forEach(field => {
        if (field.type === 'markdown') {
          // Respetamos los bloques fijos de la plantilla para no perder contexto.
          if (field.value) {
            sections.push(field.value);
          }
          return;
        }

        const rawValue = formData.get(field.id);
        const value = (rawValue || '').trim();

        if (value || field.required) {
          // Guardamos el valor aun vac√≠o si es obligatorio para facilitar validaciones posteriores.
          fieldValues[field.id] = value;
        }

        if (value) {
          const label = field.label || field.id;
          // Construimos una secci√≥n Markdown con t√≠tulo H3 para que sea f√°cil de leer.
          sections.push(`### ${label}\n${value}`);
        }
      });

      const markdownBody = sections.join('\n\n').trim();

      return {
        // Adjuntamos la plantilla para que Apps Script conozca el contexto.
        templateId: template.id,
        // T√≠tulo limpio para evitar errores por espacios extras.
        title: (formData.get('issueTitle') || '').trim(),
        // Cuerpo listo para pegar en GitHub.
        body: markdownBody,
        // Etiquetas deduplicadas en un arreglo.
        labels: Array.from(labels),
        // Valores crudos por si se requieren integraciones adicionales.
        fields: fieldValues
      };
    }

    function fallbackSubmit(url, payload) {
      // Utilizamos fetch como red de seguridad para que el reporte no se pierda.
      fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      }).catch(error => {
        // Registramos el problema en consola; el usuario ya fue informado del env√≠o.
        console.error('No se pudo entregar el issue mediante el fallback.', error);
      });
    }

    function showMessage(message, variant = 'info', options = {}) {
      issueFormMessage.textContent = '';
      issueFormMessage.className = `form-message ${variant}`;

      if (message) {
        issueFormMessage.append(document.createTextNode(message));
      }

      if (options.debugId) {
        // Adjuntamos el identificador para que soporte pueda solicitarlo sin
        // exponer detalles t√©cnicos al usuario final.
        const debugLine = document.createElement('div');
        debugLine.classList.add('form-message-debug');
        debugLine.textContent = `C√≥digo de seguimiento: ${options.debugId}`;
        issueFormMessage.append(debugLine);
      }

      const link = options.link || options;
      if (link && link.href && link.label) {
        const anchor = document.createElement('a');
        anchor.href = link.href;
        anchor.target = '_blank';
        anchor.rel = 'noreferrer noopener';
        anchor.textContent = link.label;
        anchor.classList.add('form-message-link');
        issueFormMessage.append(document.createTextNode(' '));
        issueFormMessage.append(anchor);
      }
    }

    function clearMessage() {
      issueFormMessage.textContent = '';
      issueFormMessage.className = 'form-message';
    }

    function getFocusableElements() {
      return Array.from(issueModal.querySelectorAll('a[href], button:not([disabled]), textarea, input, select, [tabindex]:not([tabindex="-1"])'));
    }

    function trapFocus(event) {
      if (event.key !== 'Tab') {
        return;
      }

      const focusable = getFocusableElements();
      if (!focusable.length) {
        return;
      }

      const first = focusable[0];
      const last = focusable[focusable.length - 1];

      if (event.shiftKey && document.activeElement === first) {
        event.preventDefault();
        last.focus();
      } else if (!event.shiftKey && document.activeElement === last) {
        event.preventDefault();
        first.focus();
      }
    }

    function handleKeydown(event) {
      if (event.key === 'Escape') {
        closeModal();
        return;
      }
      trapFocus(event);
    }

    function openModal() {
      if (modalOverlay.classList.contains('hidden')) {
        lastFocusedElement = document.activeElement;
        modalOverlay.classList.remove('hidden');
        document.body.classList.add('modal-open');
        document.addEventListener('keydown', handleKeydown);

        clearMessage();
        payloadPreview.classList.add('hidden');
        payloadPreview.textContent = '';

        if (!currentTemplateId && issueTemplates.length) {
          selectTemplate(issueTemplates[0].id);
        }

        requestAnimationFrame(() => {
          const focusable = getFocusableElements();
          (focusable[0] || issueModal).focus();
        });
      }
    }

    function closeModal() {
      if (!modalOverlay.classList.contains('hidden')) {
        modalOverlay.classList.add('hidden');
        document.body.classList.remove('modal-open');
        document.removeEventListener('keydown', handleKeydown);
        if (lastFocusedElement) {
          lastFocusedElement.focus();
        }
      }
    }

    function handleSubmit(event) {
      event.preventDefault();
      clearMessage();

      if (!currentTemplateId) {
        showMessage('Selecciona una plantilla para continuar.', 'error');
        return;
      }

      if (!issueForm.reportValidity()) {
        const invalid = issueForm.querySelector(':invalid');
        if (invalid) {
          const field = invalid.closest('.field');
          if (field) {
            field.classList.add('invalid');
          }
          invalid.focus();
        }
        return;
      }
      const sanitizedTitle = issueTitle.value.trim();
      if (!sanitizedTitle) {
        issueTitle.focus();
        showMessage('El t√≠tulo es obligatorio.', 'error');
        return;
      }

      const formData = new FormData(issueForm);
      // Reemplazamos el t√≠tulo en el formulario para evitar enviar espacios innecesarios.
      formData.set('issueTitle', sanitizedTitle);

      // Generamos el JSON final reutilizando una sola fuente de verdad para prevenir discrepancias.
      const requestPayload = toIssuePayload(formData);
      if (!requestPayload) {
        showMessage('Plantilla no disponible.', 'error');
        return;
      }

      const previewBody = requestPayload.body;
      payloadPreview.textContent = previewBody || 'Sin contenido';
      payloadPreview.classList.toggle('hidden', !previewBody);

      let beaconUrl;
      try {
        // Poka-yoke: Resolvemos la URL a trav√©s de la funci√≥n centralizada para garantizar que todos los caminos usen la misma validaci√≥n.
        beaconUrl = getBeaconUrl();
      } catch (error) {
        // Poka-yoke: Si la resoluci√≥n falla detenemos el flujo y mostramos el mensaje resultante para guiar al usuario.
        showMessage(error instanceof Error ? error.message : 'Servicio de issues no configurado. Contacta al administrador.', 'error');
        return;
      }

      const requestPayload = {
        templateId: template.id,
        title: sanitizedTitle,
        fields: fieldValues
      };

      const originalText = submitIssueBtn.textContent;
      submitIssueBtn.disabled = true;
      submitIssueBtn.textContent = 'Enviando‚Ä¶';
      showMessage('Enviando issue‚Ä¶', 'info');

      const maxAttempts = 2;
      let responseData = null;
      let lastError = null;

      for (let attempt = 1; attempt <= maxAttempts; attempt++) {
        try {
          const response = await fetch(beaconUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestPayload)
          });

          const data = await response.json().catch(() => ({}));
          if (response.ok) {
            responseData = data;
            break;
          }

          lastError = (data && data.error && data.error.message) || `Solicitud rechazada (${response.status})`;
        } catch (error) {
          lastError = error instanceof Error ? error.message : 'Error de red';
        }

        if (attempt < maxAttempts) {
          showMessage('Reintentando el env√≠o‚Ä¶', 'warning');
          await sleep(750);
        }
      }

      submitIssueBtn.disabled = false;
      submitIssueBtn.textContent = originalText;

      const friendlyError = normalizeServiceError(lastError);
      // Guardamos el identificador proporcionado por el backend para adjuntarlo
      // en cualquier mensaje que se muestre al usuario.
      const debugOptions = responseData && responseData.debugId ? { debugId: responseData.debugId } : {};

      const payloadBlob = new Blob([JSON.stringify(requestPayload)], { type: 'application/json' });
      // sendBeacon no garantiza la entrega inmediata, pero permite transmitir datos aunque la p√°gina se cierre.
      const beaconAccepted = typeof navigator.sendBeacon === 'function' && navigator.sendBeacon(issueServiceURL, payloadBlob);

      if (!beaconAccepted) {
        // Si sendBeacon falla usamos el fallback para reducir el riesgo de p√©rdida del reporte.
        fallbackSubmit(issueServiceURL, requestPayload);
      }

      closeModal();
      // Limpiamos el formulario para evitar que quede informaci√≥n sensible visible tras cerrar el modal.
      issueForm.reset();

      const template = issueTemplates.find(t => t.id === currentTemplateId);
      if (template) {
        // Repoblamos los campos para que la plantilla quede lista si la persona reabre el formulario.
        populateTemplateFields(template);
      }
    }

    renderTemplateOptions();
    if (issueTemplates.length) {
      selectTemplate(issueTemplates[0].id);
    }

    openIssueModalBtn.addEventListener('click', openModal);
    closeIssueModalBtn.addEventListener('click', closeModal);
    modalOverlay.addEventListener('click', event => {
      if (event.target === modalOverlay) {
        closeModal();
      }
    });
    issueForm.addEventListener('submit', handleSubmit);

    async function load() {
      try {
        const res = await fetch('modules.json', { cache: 'no-store' });
        modules = await res.json();
        render();
      } catch (e) {
        grid.innerHTML = '<p>No se pudo cargar <code>modules.json</code>. Verifica GitHub Pages.</p>';
      }
      footer.textContent = `√öltima actualizaci√≥n: ${new Date().toLocaleString()}`;
    }

    function badgeClass(estado) {
      if (!estado) return 'badge';
      const key = estado.toLowerCase().replace(/\s+/g,'');
      return `badge ${key}`;
    }

    function render() {
      const term = search.value.trim().toLowerCase();
      const st = statusFilter.value;
      const filtered = modules.filter(m => {
        const matchStatus = !st || m.estado === st;
        const matchText = !term || (m.nombre + ' ' + (m.descripcion||'')).toLowerCase().includes(term);
        const isEpic = m.tipo === 'epic';
        return matchStatus && matchText && isEpic;
      });

      grid.innerHTML = filtered.map(m => `
        <article class="card">
          <h3>${m.nombre}</h3>
          <span class="${badgeClass(m.estado)}">${m.estado||''}</span>
          <p class="desc">${m.descripcion||''}</p>
          <div class="progress" title="${m.porcentaje||0}%">
            <div style="width:${Math.min(100, Math.max(0, m.porcentaje||0))}%"></div>
          </div>
          <div class="meta">
            <span>Propietario: ${m.propietario||'‚Äî'}</span>
            <span>Inicio: ${m.inicio||'‚Äî'}</span>
            <span>ETA: ${m.eta||'‚Äî'}</span>
            <span>Progreso: ${m.porcentaje||0}%</span>
          </div>
          ${Array.isArray(m.enlaces) && m.enlaces.length ? (`<div class="meta">` + m.enlaces.map(e => `<a class="link" href="${e.url}" target="_blank" rel="noopener">${e.label}</a>`).join(' ¬∑ ') + `</div>`) : ''}
        </article>
      `).join('');

      if (!filtered.length) {
        grid.innerHTML = '<p>No hay m√≥dulos con  ese filtro/b√∫squeda.</p>';
      }
    }

    statusFilter.addEventListener('change', render);
    search.addEventListener('input', render);

    load();
  </script>
</body>
</html>
